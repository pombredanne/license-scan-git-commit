#!/usr/bin/env python

import subprocess
from collections import OrderedDict
import re
import os
import json

DIFF_TREE_RE = re.compile("^:(?P<src_mode>[0-9]{6}) (?P<dst_mode>[0-9]{6}) (?P<src_hash>[0-9a-f]{7,40}) (?P<dst_hash>[0-9a-f]{7,40}) (?P<status>[ADMTUX]|[CR][0-9]{1,3})\s+(?P<file1>\S+)(?:\s+(?P<file2>\S+))?$", re.MULTILINE)
SCANCODE = '../scancode-toolkit-2.0.1/scancode'
OUTPUT_DIR = 'outputs'

def run_git(args):
    args = ['git'] + args
    git = subprocess.Popen(args, stdout = subprocess.PIPE)
    details = git.stdout.read()
    details = details.decode("utf-8").strip()
    return details

def run_scancode(args):
    args = [SCANCODE] + args
    scancode = subprocess.Popen(args, stdout = subprocess.PIPE)
    details = scancode.stdout.read()
    details = details.decode("utf-8").strip()
    return details

def get_actual_file_name(file_name):
    file_name_parts = file_name.strip().split('/')
    return file_name_parts[len(file_name_parts) - 1].encode("ascii")

def generate_ref_file(branch_name, file_name):
    actual_file_name = get_actual_file_name(file_name)
    ref_name = (branch_name + ':' + file_name).encode("ascii")
    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)
    with open(os.path.join(OUTPUT_DIR, actual_file_name), 'wb') as file:
        subprocess.call(['git', 'show', ref_name], stdout=file)
    return OUTPUT_DIR + '/' + actual_file_name

def get_json_name(file_name):
    if "." not in file_name.encode("ascii"):
        return file_name + ".json"
    file_name_parts = file_name.strip().split('.')
    return ".".join(file_name_parts[0:(len(file_name_parts)-1)]) + ".json"

def check_print_license_constraints(json_file, file_name):
    if not os.path.isfile(json_file):
        "Unable to find the output json -> " + json_file
        return
    with open(json_file) as json_file_temp:    
        json_data = json.load(json_file_temp)
        files = json_data["files"]
        if files and len(files) > 0:
            licenses = files[0]["licenses"]
            if licenses: 
                if len(licenses) > 0:
                    print file_name + " -> HAS License Constraints"
                    return;
    print file_name + " -> has NO License Constraints"


def check_for_licenses_new_file(commit_sha, file_name):
    print "Scanning NEW File -> " + file_name
    branch_name = get_branch_name(commit_sha, file_name)
    #  # TODO: Check if the new file is zip extract the same
    output_file_path = generate_ref_file(branch_name, file_name)
    output_file_json = get_json_name(output_file_path)
    run_scancode(['--license', output_file_path, output_file_json])
    check_print_license_constraints(output_file_json, file_name)

def check_for_licenses_diff_from_file(commit_sha, file_name):
    print "Scanning MODIFIED File -> " + file_name
    branch_name = get_branch_name(commit_sha, file_name)
    #  # Get only the diff and check against the same
    output_file_path = generate_ref_file(branch_name, file_name)
    output_file_json = get_json_name(output_file_path)
    run_scancode(['--license', output_file_path, output_file_json])
    check_print_license_constraints(output_file_json, file_name)

def git_config():
    config = run_git(['config', '-l', '-z'])
    items = config.split("\0")
    items = filter(lambda i: len(i) > 0, items)
    items = [item.partition("\n")[0:3:2] for item in items]
    return OrderedDict(items)

GIT_CONFIG = git_config()

def get_from_git_config(key, default=None):
    return GIT_CONFIG.get(key, default)

def get_branch_name(commit, ref):
    branches = run_git(['branch', '--contains', commit]).split('\n')
    CURR_BRANCH_RE = re.compile('^\* \w+$')
    curr_branch = None

    if len(branches) > 1:
        on_master = False
        for branch in branches:
            if CURR_BRANCH_RE.match(branch):
                curr_branch = branch.strip('* \n')
            elif branch.strip() == 'master':
                on_master = True

        if curr_branch is None and on_master:
            curr_branch = 'master'

    if curr_branch is None:
        curr_branch = branches[0].strip('* \n')

    base_ref = 'refs/heads/%s' % curr_branch

    if base_ref == ref:
        print "branch_name -> None"
        return None
    else:
        print "branch_name -> " + base_ref
        return base_ref

def scan_revisions(old, new, head_commit=False):
    if re.match("^0+$", old):
        if not head_commit:
            return []

        commit_range = '%s~1..%s' % (new, new)
    else:
        commit_range = '%s..%s' % (old, new)

    revs = run_git(['rev-list', '--pretty=medium', '--reverse', commit_range])
    sections = revs.split('\n\n')

    revisions = []
    s = 0
    while s < len(sections):
        lines = sections[s].split('\n')

        commit_sha = lines[0].strip().split(' ')[1].encode("ascii")
        output = run_git(['diff-tree', '-r', '-C', '%s' % commit_sha])
        for i in DIFF_TREE_RE.finditer(output):
            item = i.groupdict()
            status = item['status']
            file_name = item['file1'];
            if item['status'] == 'A':      
                check_for_licenses_new_file(commit_sha, file_name)
            elif item['status'] == 'M':    
                check_for_licenses_diff_from_file(commit_sha, file_name)
            
        s+=2

    return revisions

# # MAIN CODE
# if __name__ == "__main__":
#     for line in sys.stdin:
#         old, new, ref = line.strip().split(' ')
#         print "old -> " + old + "| new -> " + new + " | ref -> " + ref
#         revisions = scan_revisions(old, new, ref)
#         print revisions

# # TEST Code
revisions = scan_revisions('54bcd0c1903d2322e1674cd052b06288761d0b66', '438b78dc04573cc39f90674567e82a4a9a8b00e8')

